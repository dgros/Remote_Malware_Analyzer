#include "process.h"
// #include "sockets.h"
#include "pigaregmonitor.h"
VOID GetUnicodeName(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status,ntStatus;
	CLIENT_ID ClientId;
	int i=0,ppid=0, sid=0;
	char temp_buffer[1000];
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PVOID unicode;
	ANSI_STRING str_ansi;
	WCHAR	System[]  = L"System";
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
	{	
		return;
	}
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, NULL, 0, &ret);
		if(rc == STATUS_INFO_LENGTH_MISMATCH)
		{
			unicode = ExAllocatePool(PagedPool, ret);
			if(unicode != NULL)
			{	
				rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, unicode, ret, &ret);
				if( rc == STATUS_SUCCESS)
				{
					if(pid == 4)
					{
						RtlInitUnicodeString(unicode , System);
					}
					else
					{
						RtlUnicodeStringToAnsiString(&str_ansi, unicode, TRUE);
						RtlZeroMemory(&temp_buffer, sizeof(temp_buffer));
						ppid = GetParentId(pid);
						sid = GetSessionId(pid);
						sprintf_s(temp_buffer, sizeof(temp_buffer), "Process name : %s pid=%i ppid=%i sid=%i\n",str_ansi.Buffer ,  pid, ppid, sid);
						// ntStatus = senddata(sock, temp_buffer, sizeof(temp_buffer));
						ntStatus = AddInQueue(temp_buffer);
						RtlFreeAnsiString(&str_ansi);
					}
				}
				else
					RtlInitUnicodeString(unicode, L"Echec" );
				if(unicode != NULL) ExFreePool(unicode);
			}
			ZwClose(openproc);
		}
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}

	return;
}


int GetSessionId(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PROCESS_SESSION_INFORMATION unicode;
	WCHAR	System[]  = L"System";
	int retour = 0;
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
		return 0;
	
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessSessionInformation, &unicode, sizeof(unicode), &ret);
		if( rc == STATUS_SUCCESS)
		{
			retour = unicode.SessionId;
			// DbgPrint("Session %i\n", retour);
		}
		ZwClose(openproc);
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}

	return retour;
}

int GetParentId(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PROCESS_BASIC_INFORMATION unicode;
	WCHAR	System[]  = L"System";
	int retour = 0;
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
		return 0;
	
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessBasicInformation, &unicode, sizeof(unicode), &ret);
		if( rc == STATUS_SUCCESS)
		{
			retour = unicode.InheritedFromUniqueProcessId;
		}
		ZwClose(openproc);
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}
			

	return retour;
}

#include "fltdrvKernel.h"
#include "sockets.h"

NTSTATUS
initwsk(PWSK_REGISTRATION clireg, PWSK_PROVIDER_NPI pronpi)
{
	NTSTATUS            status;
	WSK_CLIENT_NPI      clinpi;
	WSK_CLIENT_DISPATCH dispatch = { MAKE_WSK_VERSION(1, 0), 0, NULL };

	clinpi.ClientContext = NULL;
	clinpi.Dispatch      = &dispatch;

	status = WskRegister(&clinpi, clireg);
	if(!NT_SUCCESS(status)){
		DbgPrint("WskRegister() error : 0x%X\n", status);
		return status;
	}

	status = WskCaptureProviderNPI(clireg, WSK_INFINITE_WAIT, pronpi);
	if(!NT_SUCCESS(status)){
		DbgPrint("WskCaptureProviderNPI() error : 0x%X\n", status);
		WskDeregister(clireg);
		return status;
	}

	return STATUS_SUCCESS;
}

VOID
cleanupwsk(PWSK_REGISTRATION clireg)
{
	WskReleaseProviderNPI(clireg);
	WskDeregister(clireg);

	return;
}

NTSTATUS
connecttoserver(PWSK_PROVIDER_NPI pronpi, PSOCKADDR remaddr, PWSK_SOCKET *sock)
{
	NTSTATUS status;
	PIRP     irp;
	KEVENT   event;
	ULONG	 SocketOptionState;
	SOCKADDR locaddr =  {0} ;

	irp = IoAllocateIrp(1, FALSE);
	if(!irp){
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	KeInitializeEvent(&event, NotificationEvent, FALSE);

	IoSetCompletionRoutine(irp, createcomplete, &event, TRUE, TRUE, TRUE);

	locaddr.sa_family = remaddr->sa_family;
	
	status = pronpi->Dispatch->WskSocketConnect(
			pronpi->Client, /* Client             */
			SOCK_STREAM,    /* SocketType         */
			IPPROTO_TCP,    /* Protocol           */
			&locaddr,       /* LocalAddress       */
			remaddr,        /* RemoteAddress      */
			0,              /* Flags              */
			NULL,           /* SocketContext      */
			NULL,           /* Dispatch           */
			NULL,           /* OwningProcess      */
			NULL,           /* OwningThread       */
			NULL,           /* SecurityDescriptor */
			irp);           /* Irp                */
	if(!NT_SUCCESS(status)){
		IoFreeIrp(irp);
		return status;
	}

	if(status == STATUS_PENDING){
		KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

		status = irp->IoStatus.Status;
		if(!NT_SUCCESS(status)){
			IoFreeIrp(irp);
			return status;
		}
	}

	*sock = (PWSK_SOCKET)irp->IoStatus.Information;
	// SocketOptionState =1;
	// status = WskControlSocket(
			// sock,
			// WskSetOption,
			// TCP_NODELAY,
			// SOL_SOCKET,
			// sizeof(ULONG),
			// &SocketOptionState,
			// NULL,
			// NULL,
			// irp);
			

	IoFreeIrp(irp);

	return STATUS_SUCCESS;
}

NTSTATUS
createcomplete(PDEVICE_OBJECT devobj, PIRP irp, PVOID context)
{
	UNREFERENCED_PARAMETER(devobj);
	UNREFERENCED_PARAMETER(irp);

	KeSetEvent((PKEVENT)context, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
senddata(PWSK_SOCKET sock, PVOID data, ULONG datal)
{
	WSK_BUF  wskbuf;
	NTSTATUS status;
	KEVENT   event;
	PIRP     irp;

	irp = IoAllocateIrp(1, FALSE);
	if(!irp){
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	KeInitializeEvent(&event, NotificationEvent, FALSE);

	IoSetCompletionRoutine(irp, senddatacomplete, &event, TRUE, TRUE, TRUE);

	wskbuf.Mdl = IoAllocateMdl(data, datal, FALSE, FALSE, NULL);
	if(!wskbuf.Mdl){
		DbgPrint("Failed to allocate MDL!\n");
		return STATUS_MORE_PROCESSING_REQUIRED;
	}
	MmBuildMdlForNonPagedPool(wskbuf.Mdl);
	wskbuf.Offset = 0;
	wskbuf.Length = datal;

	status = ((PWSK_PROVIDER_CONNECTION_DISPATCH)(sock->Dispatch))->WskSend(sock, &wskbuf, 0, irp);
	if(status == STATUS_PENDING){
		KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

		status = irp->IoStatus.Status;
	}

	IoFreeIrp(irp);

	return status;
}

NTSTATUS
senddatacomplete(PDEVICE_OBJECT devobj, PIRP irp, PVOID context)
{
	UNREFERENCED_PARAMETER(devobj);
	UNREFERENCED_PARAMETER(irp);

	KeSetEvent((PKEVENT)context, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
disconnectfromserver(PWSK_SOCKET sock)
{
	NTSTATUS status;
	KEVENT   event;
	PIRP     irp;

	irp = IoAllocateIrp(1, FALSE);
	if(!irp){
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	KeInitializeEvent(&event, NotificationEvent, FALSE);

	IoSetCompletionRoutine(irp, disconnectcomplete, &event, TRUE, TRUE,
			TRUE);

	status = ((PWSK_PROVIDER_CONNECTION_DISPATCH)(sock->Dispatch))->
		WskCloseSocket(sock, irp);
	if(status == STATUS_PENDING){
		KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

		status = irp->IoStatus.Status;
	}

	IoFreeIrp(irp);

	return status;
}

NTSTATUS
disconnectcomplete(PDEVICE_OBJECT devobj, PIRP irp, PVOID context)
{
	UNREFERENCED_PARAMETER(devobj);
	UNREFERENCED_PARAMETER(irp);

	KeSetEvent((PKEVENT)context, IO_NO_INCREMENT, FALSE);

	return STATUS_MORE_PROCESSING_REQUIRED;
}


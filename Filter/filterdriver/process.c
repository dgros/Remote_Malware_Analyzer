#include "process.h"


unsigned long hash_process(char * str)
{
	unsigned long hash = 5321;
	int c;
	if(str == NULL)
		return 0;
	while(c = *str++)
		hash = ((hash <<5) + hash) + c;
	return hash;
}

char * ComputeSSID(PUNICODE_STRING fullname)
{
	ANSI_STRING str_ansi;
	int i=0, j=0;
	char buffer_ansi[1024];
	char * ssid_return = NULL;
	int taille = strlen("\\Device\\HarddiskVolume2");
	int IsExe=0;

	RtlZeroMemory(&buffer_ansi, sizeof(buffer_ansi));
	if(fullname == NULL)
		return NULL;

	RtlUnicodeStringToAnsiString(&str_ansi, fullname, TRUE);

	if(strcmp(str_ansi.Buffer,"System") ==0)
	{
		DbgPrint("system_t\n");
		RtlFreeAnsiString(&str_ansi);
		return NULL;
	}
	
	if(str_ansi.Buffer != NULL)
	{
		if(str_ansi.Length > sizeof(buffer_ansi) ) return NULL;
		
		sprintf_s(buffer_ansi,sizeof(buffer_ansi),"%s\0", &str_ansi.Buffer[taille]);

		RtlFreeAnsiString(&str_ansi);
		
		ssid_return =  ExAllocatePool(PagedPool, sizeof(char)*2048);
		
		if(ssid_return == NULL)
		{
			DbgPrint("Echec ExallocatePool for sid compute \n");
			return NULL;
		}

		while(buffer_ansi[i] != '\0' || (i == sizeof(ssid_return)))
		{
			if( (i==0) && (buffer_ansi[i]!='\\'))
				return NULL;
			if( (i==0) && (buffer_ansi[i] =='\\'))
			{
				i++;
				continue;
			}
			if(buffer_ansi[i] == '\\')
			{
				ssid_return[j] = '_';
			}
			else
			{
				if(buffer_ansi[i] ==  ' ')
				{
					i++;
					continue;
				}
				else
				{
					if(buffer_ansi[i] <= 'Z' && buffer_ansi[i] >= 'A')
						ssid_return[j]= (buffer_ansi[i] -'A') + 'a';
					else
						ssid_return[j] = buffer_ansi[i];
				}
			}
			i++;
			j++;
		}
			ssid_return[j]='\0';
			DbgPrint("Process security context : %s \n", ssid_return);
	}
	return NULL;
}

INT GetUnicodeName_only(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	char temp_buffer[1000];
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PVOID unicode;
	ANSI_STRING str_ansi;
	WCHAR	System[]  = L"System";
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	if(pid%4 !=0)
	{
		DbgPrint("pid = %i Proces %4 != 0\n", pid);
		return -1;
	}
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
	{	
		return -1;
	}
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
	__try{
		rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
		if(NT_SUCCESS(rc))
		{
			rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, NULL, 0, &ret);
			if(rc == STATUS_INFO_LENGTH_MISMATCH)
			{
				unicode = ExAllocatePool(PagedPool, ret);
				if(unicode != NULL)
				{	
					rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, unicode, ret, &ret);
					if( rc == STATUS_SUCCESS)
					{
						if(pid == 4)
						{
							// RtlInitUnicodeString(unicode , System);
							AddInQueue("Parent Process name : System pid=4 \n");
						}
						else
						{
							RtlUnicodeStringToAnsiString(&str_ansi, unicode, TRUE);
							RtlZeroMemory(&temp_buffer, sizeof(temp_buffer));
							sprintf_s(temp_buffer, sizeof(temp_buffer), "Parent Process name : %s pid=%i \n",str_ansi.Buffer ,  pid);
							// GetSessionId(pid);
							// DbgPrint("%s", temp_buffer);
							AddInQueue(temp_buffer);
							RtlFreeAnsiString(&str_ansi);
						}
						// ComputeSSID(unicode);
					}
					else
						RtlInitUnicodeString(unicode, L"Echec" );
					if(unicode != NULL) ExFreePool(unicode);
				}
				ZwClose(openproc);
			}
		}
		else
		{
			DbgPrint("Unable to open process %i\n", i);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		rc=GetExceptionCode();
		DbgPrint("Exception GetOnly Nuame : %x\n", rc);
		return -1;
	}
	return 0;
}

VOID GetUnicodeName(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0,ppid=0, sid;
	char temp_buffer[1000];
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PVOID unicode;
	ANSI_STRING str_ansi;
	WCHAR	System[]  = L"System";
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
	{	
		return;
	}
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, NULL, 0, &ret);
		if(rc == STATUS_INFO_LENGTH_MISMATCH)
		{
			unicode = ExAllocatePool(PagedPool, ret);
			if(unicode != NULL)
			{	
				rc = ZwQueryInformationProcess(openproc, ProcessImageFileName, unicode, ret, &ret);
				if( rc == STATUS_SUCCESS)
				{
					if(pid == 4)
					{
						// RtlInitUnicodeString(unicode , System);
						AddInQueue("Process name : System pid=4\n" );
					}
					else
					{
						RtlUnicodeStringToAnsiString(&str_ansi, unicode, TRUE);
						RtlZeroMemory(&temp_buffer, sizeof(temp_buffer));
						AddInQueue("---- Begin\n");
						ppid = GetParentId(pid);
						sid = GetSessionId(pid);
						sprintf_s(temp_buffer, sizeof(temp_buffer), "Process name : %s pid=%i ppid=%i sid=%i\n",str_ansi.Buffer ,  pid, ppid,sid);
						// DbgPrint("%s", temp_buffer);
						AddInQueue(temp_buffer);
						
						AddInQueue("---- END\n");
						
						RtlFreeAnsiString(&str_ansi);
					}
					// ComputeSSID(unicode);
				}
				else
					RtlInitUnicodeString(unicode, L"Echec" );
				if(unicode != NULL) ExFreePool(unicode);
			}
			ZwClose(openproc);
		}
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}

	return;
}


int GetSessionId(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PROCESS_SESSION_INFORMATION unicode;
	WCHAR	System[]  = L"System";
	int retour = 0;
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
		return 0;
	
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessSessionInformation, &unicode, sizeof(unicode), &ret);
		if( rc == STATUS_SUCCESS)
		{
			retour = unicode.SessionId;
			// AddInQueue("Session %i\n", retour);
		}
		ZwClose(openproc);
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}

	return retour;
}

int GetParentId(int pid)
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PROCESS_BASIC_INFORMATION unicode;
	WCHAR	System[]  = L"System";
	int retour = 0;
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	pep=NULL;
	PsLookupProcessByProcessId((HANDLE)pid,&pep);
	if(pep == NULL)
		return 0;
	
	ClientId.UniqueProcess = (HANDLE) pid;
	ClientId.UniqueThread = 0;
		
	rc = ZwOpenProcess(&openproc, PROCESS_ALL_ACCESS, &ObjectAttributes , &ClientId);
	if(rc == STATUS_SUCCESS)
	{
		rc = ZwQueryInformationProcess(openproc, ProcessBasicInformation, &unicode, sizeof(unicode), &ret);
		if( rc == STATUS_SUCCESS)
		{
			retour = unicode.InheritedFromUniqueProcessId;
		}
		ZwClose(openproc);
	}
	else
	{
		DbgPrint("Unable to open process %i\n", i);
	}
	if(retour != 0)
	{
		pep=NULL;
		PsLookupProcessByProcessId((HANDLE)retour,&pep);
		if(pep != NULL)
			GetParentId(retour);
		//else
			
	}
	GetUnicodeName_only(retour);			

	return retour;
}



int DetectPid()
{
	PEPROCESS pep;
	ULONG ret,retlen;
	NTSTATUS rc,status;
	CLIENT_ID ClientId;
	int i=0;
	HANDLE openproc;
	OBJECT_ATTRIBUTES ObjectAttributes;
	PVOID unicode;
	WCHAR	System[]  = L"System";
    
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = NULL;
	
	for( i = 0 ; i < 65535; i++ )
	{
		if(i%4 != 0) continue;
		
		pep=NULL;
		PsLookupProcessByProcessId((HANDLE)i,&pep);
		if(pep == NULL)
			continue;
		GetUnicodeName(i);

	}
	AddInQueue("------- Fin du detect PID\n");
	return 1;
}

VOID CreateRoutine( __in_opt PUNICODE_STRING  FullImageName, __in HANDLE  ProcessId, __in PIMAGE_INFO  ImageInfo  )
{
	 ANSI_STRING str_ansi;
	 LARGE_INTEGER time;
	 PEPROCESS pep;
	char buffer[1000];
	char buffer_write[1000];
	 RtlUnicodeStringToAnsiString(&str_ansi, FullImageName, TRUE);
	
	if(_stricmp(&str_ansi.Buffer[strlen(str_ansi.Buffer)-strlen(".exe")],".exe") != 0)
	{
		AddInQueue("------- Loading\n");
		sprintf_s(buffer,sizeof(buffer),"trace=%i , cpu=%i\n",trace++, KeGetCurrentProcessorNumber());
		AddInQueue(buffer);
		KeQuerySystemTime(&time);
		RtlZeroMemory(&buffer, sizeof(buffer));
		sprintf_s(buffer,sizeof(buffer),"timestamp=%I64d\n",time.QuadPart);
		AddInQueue(buffer);
		
		AddInQueue("Access : load\n");
		if((int)ProcessId != 0 && (int)ProcessId != 4)
		{
			PsLookupProcessByProcessId(ProcessId,&pep);
			sprintf_s(buffer_write,sizeof(buffer_write), "pid : %s %i \n",PsGetProcessImageFileName(pep), (int)ProcessId);
			AddInQueue(buffer_write);
		}
		else
		{
			sprintf_s(buffer_write,sizeof(buffer_write), "pid : System %i \n",(int)ProcessId);
			AddInQueue(buffer_write);
		}
		RtlZeroMemory(&buffer_write, sizeof(buffer_write));
		sprintf_s(buffer_write,sizeof(buffer_write), "Object Name : %s \n", str_ansi.Buffer);
		AddInQueue(buffer_write);
		AddInQueue("------- End loading\n");
	 }
	if(str_ansi.Length != 0) RtlFreeAnsiString(&str_ansi);
}

VOID CreateProcessNotify(
     HANDLE Process,
	 HANDLE ProcessId,
	 BOOLEAN Create
)
{
	if(Create == TRUE)
	{
		AddInQueue("------ Create process\n");
		GetUnicodeName((int) ProcessId);

	}
	else
	{
		AddInQueue("------ Descruction process\n");
		GetUnicodeName((int)ProcessId);
	}
}


